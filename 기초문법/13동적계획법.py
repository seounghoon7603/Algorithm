# 다이나믹 프로그래밍 (동적계획법)
# 조건 1 : 최적 부분 구조
# 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰문제를 해결가능
# 조건 2 : 중복되는 부분 문제
# 동일한 작은 문제를 반복적으로 해결

# 피보나치 수열
# 점화식 : 인접한 항들 사이의 관계식

# 제귀적으로 피보나치 구현하면 O(2의 N제곱) 이다
# 다이나믹프로그래밍으로 개선필요 ( 한번계산한건 또 계산 안하도록 )

# 메모이제이션
# 다이나믹 프로그래밍을 구현하는 방법 중 하나
# 한번 계산한 결과를 메모리 공간에 메모 ( 캐싱 이라고도 한다 )

# 탑다운 vs 바텀업
# 탑다운(메모이제이션) 방식은 하향식이라고도 함 ( 재귀적 호출 )
# 바텀업 방식은 상향식이라고도 하고 반복문을 사용함
# 다이나믹 프로그래밍의 전형적인 형태는 바텀업 방식
# 결과 저장용 리스트는 DB테이블 이라고 함

# TopUP
d = [0] * 100

def fibo(x):
  if x==1 or x==2:
    return 1
  if d[x] != 0:
    return d[x]
  d[x] = fibo(x-1) + fibo(x-2)
  return d[x]
print(fibo(99))

# BottomUP
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
   d[i] = d[i-1] + d[i-2]

print(d[n])

# 다이나믹 프로그래밍 vs 분할 정복
# 두개 모두 최적 부분 구조를 가질 때 사용 가능
# 차이점은 부분 문제의 중복
# 다이나믹 프로그래밍은 각 부분 문제들이 서로 영향을 주고 문제가 중복됨
# 분할 정복 문제는 동일한 부분 문제가 반복적으로  계산되지 않음


## 접근법
# 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요
# 그리디, 구현, 완전 탐색 등 아이디어로 문제 해결 가능한가? 먼저 고민
# 다른 알고리즘 안떠오르면 다이나믹프로그래밍 고려
# 일단 재귀 함수로 비효율적 완전 탐색 프로그램 작성 뒤 ( 탑다운 ) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있다면, 코드를 개선하는 방법 사용

# 일반적인 코테 수준에서 기본 유형의 다이나믹 프로그래밍 문제가 출제됨

